/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to You under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.apache.jackrabbit.oak.blob.cloud.s3;

import static org.apache.jackrabbit.oak.blob.cloud.s3.S3DataStoreUtils.getS3Config;
import static org.apache.jackrabbit.oak.blob.cloud.s3.S3DataStoreUtils.isS3Configured;
import static org.apache.jackrabbit.oak.blob.cloud.s3.TestS3Ds.getBackdatedDate;
import static org.junit.Assert.assertTrue;
import static org.junit.Assume.assumeTrue;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.URISyntaxException;
import java.util.Date;
import java.util.List;
import java.util.Properties;
import java.util.Random;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.function.Function;

import javax.jcr.RepositoryException;

import com.google.common.collect.Lists;
import org.apache.jackrabbit.core.data.DataIdentifier;
import org.apache.jackrabbit.core.data.DataRecord;
import org.apache.jackrabbit.core.data.DataStoreException;
import org.apache.jackrabbit.core.data.RandomInputStream;
import org.apache.jackrabbit.oak.plugins.blob.BlobStoreStats;
import org.apache.jackrabbit.oak.plugins.blob.datastore.BlobStoreStatsTestableFileDataStore;
import org.apache.jackrabbit.oak.plugins.blob.datastore.DataStoreBlobStore;
import org.apache.jackrabbit.oak.spi.blob.stats.BlobStatsCollector;
import org.apache.jackrabbit.oak.stats.DefaultStatisticsProvider;
import org.apache.jackrabbit.oak.stats.StatisticsProvider;
import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.TemporaryFolder;

public class S3DataStoreStatsTest {
    @Rule
    public TemporaryFolder folder = new TemporaryFolder(new File("target"));

    private BlobStoreStats stats;
    private DataStoreBlobStore dsbs;
    private String bucket;

    private static Date overallStartTime = getBackdatedDate();
    private Date thisTestStartTime;
    private static List<String> createdBucketNames = Lists.newArrayList();

    @BeforeClass
    public static void assumptions() {
        assumeTrue(isS3Configured());
    }

    @Before
    public void setup() throws IOException, RepositoryException, URISyntaxException {
        Random randomGen = new Random();
        thisTestStartTime = getBackdatedDate();
        Properties props = getS3Config();
        bucket =
                String.valueOf(randomGen.nextInt(9999)) + "-" + String.valueOf(randomGen.nextInt(9999))
                        + "-s3ds-unittest-autogenerated";
        createdBucketNames.add(bucket);
        props.setProperty(S3Constants.S3_BUCKET, bucket);
        props.setProperty("secret", "123456");

        ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
        StatisticsProvider statsProvider = new DefaultStatisticsProvider(executor);
        stats = new BlobStoreStats(statsProvider);

        S3DataStore ds = new GetRecDelayedS3DataStore(stats);
        ds.setProperties(props);
        ds.init(folder.newFolder().getAbsolutePath());

        dsbs = new DataStoreBlobStore(ds);
        dsbs.setBlobStatsCollector(stats);
    }

    @After
    public void tearDown() {
        try {
            S3DataStoreUtils.deleteBucket(bucket, thisTestStartTime);
        }
        catch (Exception ignore) { }
    }

    @AfterClass
    public static void verifyAllBucketsDeleted() {
        for (String bucket : createdBucketNames) {
            try {
                S3DataStoreUtils.deleteBucket(bucket, overallStartTime);
            }
            catch (Exception ignore) { }
        }
    }


    @Test
    public void testGetRecordStats() throws IOException, DataStoreException {
        DataRecord addedRecord = dsbs.addRecord(new RandomInputStream(System.currentTimeMillis(), 20*1024));

        long getRecordTimeLastMinuteBefore = sum((long[]) stats.getDownloadRateHistory().get("per second"));

        DataRecord readRecord = dsbs.getRecord(addedRecord.getIdentifier());
        try (InputStream in = readRecord.getStream()) {
            while (in.available() > 0) { in.read(); }
        }

        long getRecordTimeLastMinuteAfter = waitForNonzeroMetric(
                input -> sum((long[]) input.getDownloadRateHistory().get("per second")), stats);

        assertTrue(getRecordTimeLastMinuteBefore < getRecordTimeLastMinuteAfter);
    }


    private long sum(long[] a) {
        long rv = 0L;
        for (long l : a) {
            rv += l;
        }
        return rv;
    }

    private <T> Long waitForNonzeroMetric(Function<T, Long> f, T input) {
        int intervalMilliseconds = 100;
        int waitMilliseconds = 1000;
        long end = System.currentTimeMillis() + waitMilliseconds;
        Long output = f.apply(input);
        if (null != output && output > 0L) {
            return output;
        }
        do {
            try {
                Thread.sleep(intervalMilliseconds);
            }
            catch (InterruptedException e) { }
            output = f.apply(input);
            if (null != output && output > 0L) {
                return output;
            }
        }
        while (System.currentTimeMillis() < end);
        return 0L;
    }

    private static class GetRecDelayedS3DataStore extends S3DataStore {
        private BlobStatsCollector stats;
        GetRecDelayedS3DataStore(BlobStatsCollector stats) {
            this.stats = stats;
        }

        @Override
        public DataRecord getRecord(DataIdentifier identifier) throws DataStoreException {
            long start = System.nanoTime();
            try {
                Thread.sleep(1000);
            }
            catch (InterruptedException e) { }
            return BlobStoreStatsTestableFileDataStore.ReadDelayedDataRecord.wrap(super.getRecord(identifier), stats, start);
        }
    }
}
